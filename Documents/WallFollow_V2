#!/usr/bin/env python
import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image
from ackermann_msgs.msg import AckermannDriveStamped
from cv_bridge import CvBridge


class YellowNode:
    def __init__( self ):
        rospy.Subscriber("/zed/rgb/image_rect_color",Image, self.callback, queue_size = 1)
        self.bridge=CvBridge()
        rospy.Subscriber("ackermann_cmd_mux/output", AckermannDriveStamped,self.ackermann_cmd_input_callback)
        
        # publish to Ackermann
        self.cmd_pub = rospy.Publisher('/vesc/ackermann_cmd_mux/input/navigation', AckermannDriveStamped, queue_size = 10)

    
        self.kp = 1.2
        self.kd = 0.4
        self.ki = 0.02

        '''
        self.kp = 1.5
        self.kd = 0.8
        self.ki = 0.02
        chidas:
        1.2
        0.4
        0.02
        '''

        self.average = 0
        self.av = 0
        self.idealDis = 0.5
        self.error = 0

        self.prop = 0
        self.deriv = 0
        self.integ = 0
        self.prev_error = 0
        self.output = 0

        self.prev_time = 0
        self.current_time = 0


  def callback(self,msg):
      self.msg=msg
      frame = self.bridge.imgmsg_to_cv2(msg)
      self.hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)   
      lower_yellow = np.array([20,200,200])
      upper_yellow = np.array([50,255,255])
      self.mask=cv2.inRange(self.hsv,lower_yellow,upper_yellow)
      rows=self.mask.shape[0]
      cols=self.mask.shape[1]
      area1=np.array([[[cols,0], [cols/2,0], [cols,rows],[cols,rows-1]]],dtype=np.int32)
      area2=np.array([[[cols/2,0], [0,0], [0,rows],[1,rows]]],dtype=np.int32)
      cv2.fillPoly(self.mask,area1,0)
      cv2.fillPoly(self.mask,area2,0)
      cv2.imshow('mask',self.mask)
      contours,hierachy=cv2.findContours(self.mask.copy(), 1, cv2.CHAIN_APPROX_NONE)    
      if len(contours) > 0:
          c = max(contours, key=cv2.contourArea)
          M = cv2.moments(c)
          cx = int(M['m10']/M['m00'])
          cy = int(M['m01']/M['m00'])
          cv2.line(self.mask,(cx,0),(cx,720),(255,0,0),0)
          cv2.line(self.mask,(0,cy),(1280,cy),(255,0,0),0)
          cv2.drawContours(self.mask, contours, -1, (0,255,0), 1)
        
    print cx
    cv2.imshow("mask",self.mask)
    cv2.waitKey(1)
    #cv2.bitwise_and(mask,x, mask=mask)
    #threshold=[]
    #width=len(self.mask[0])
    #height=len(self.mask)
    
    #self.region=cv2.bitwise_and(mask,y)
    
    #print self.msg.header
    
    self.error=float(cx-cols/2)
    PID(error)

    def PID(self, error):
        
        self.current_time = time.time()

        #P
        self.prop = self.kp * error

        #I
        self.integ = self.ki * ((error + self.prev_error) * (self.current_time - self.prev_time))

        #D
        self.deriv = self.kd * ((error - self.prev_error) / (self.current_time - self.prev_time))

        self.prev_error = error
        self.prev_time = self.current_time

        self.output = self.prop + self.integ + self.deriv

        print("P = {} I = {} D = {}, PID = {}".format(round(self.prop, 4), round(self.integ, 4), round(self.deriv, 4), round(self.output, 4)))

        self.ackermann_cmd_input_callback(AckermannDriveStamped())

    def ackermann_cmd_input_callback(self, msg):
        msg.drive.speed = 0.5
        msg.drive.steering_angle = self.output
        msg.drive.steering_angle_velocity = 0.5
        self.cmd_pub.publish(msg)

              
if __name__ == "__main__":
    rospy.init_node("Yellow_Node", anonymous = True)
    node =YellowNode()
    rospy.spin()
